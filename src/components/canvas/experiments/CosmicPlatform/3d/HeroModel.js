/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect, useMemo } from 'react';
import {
  useGLTF,
  useTexture,
  shaderMaterial,
  Points,
  Point,
} from '@react-three/drei';
import { extend, useFrame, useThree } from '@react-three/fiber';
import model from '../models/hero_model.glb';
import baked from '../img/heroBake.jpg';
import {
  BufferAttribute,
  Vector3,
  FloatType,
  NormalBlending,
  Color,
  Vector2,
} from 'three';
import { gsap, Power1 } from 'gsap';
import pointsVertexShader from '../shaders/points/vertex.glsl';
import pointsFragmentShader from '../shaders/points/fragment.glsl';
import portalVertexShader from '../shaders/portal/vertex.glsl';
import portalFragmentShader from '../shaders/portal/fragment.glsl';
import {
  EffectComposer,
  Select,
  Selection,
  SelectiveBloom,
} from '@react-three/postprocessing';

const PointsMaterial = shaderMaterial(
  {
    uTime: 0,
    uMouse: new Vector3(0, 0, 0),
  },
  pointsVertexShader,
  pointsFragmentShader,
  (shaderMaterial) => {
    shaderMaterial.vertexColors = true;
    shaderMaterial.transparent = true;
    shaderMaterial.depthWrite = false;
    shaderMaterial.blending = NormalBlending;
  }
);

const PortalMaterial = shaderMaterial(
  {
    uTime: 0,
    uMouse: new Vector3(0, 0, 0),
    uColor1: new Color('#ff9e9e'),
    uColor2: new Color('#c0def2'),
  },
  portalVertexShader,
  portalFragmentShader
);

extend({ PointsMaterial, PortalMaterial });

export default function Model(props) {
  const group = useRef();
  const letters = useRef();
  const airRock1 = useRef();
  const airRock2 = useRef();
  const airRock3 = useRef();
  const airRock4 = useRef();
  const pointsRef = useRef();
  const emissionRef = useRef();
  const platformRef = useRef();

  const camera = useThree((state) => state.camera);
  const m = useRef(new Vector2());

  const bakedTex = useTexture(baked.src);

  bakedTex.flipY = false;

  const pointCount = useMemo(() => 100, []);
  const points = useMemo(() => {
    let arr = [];

    for (let i = 0; i < pointCount; i++) {
      let x = Math.random() * 2 - 1;
      let y = Math.random() * 2 - 1;
      let z = Math.random() * 2 - 1;

      arr.push(x, y, z);
    }

    return new Float32Array(arr);
  }, [pointCount]);

  const aOffset = useMemo(() => {
    let arr = [];

    for (let i = 0; i < pointCount; i++) {
      let offset = Math.random();
      arr[i] = offset;
    }

    return new Float32Array(arr);
  }, [pointCount]);

  useEffect(() => {
    gsap.to(airRock1.current.position, {
      duration: 2.8,
      ease: Power1.easeInOut,
      y: 3,
      repeat: -1,
      yoyo: true,
    });

    gsap.to(airRock2.current.position, {
      duration: 3.2,
      ease: Power1.easeInOut,
      y: 12.5,
      repeat: -1,
      yoyo: true,
    });

    gsap.to(airRock3.current.position, {
      duration: 2.4,
      ease: Power1.easeInOut,
      y: 9,
      repeat: -1,
      yoyo: true,
    });

    gsap.to(airRock4.current.position, {
      duration: 3.25,
      ease: Power1.easeInOut,
      y: 4.3,
      repeat: -1,
      yoyo: true,
    });
  }, []);

  useEffect(() => {
    pointsRef.current.geometry.setAttribute(
      'aOffset',
      new BufferAttribute(aOffset, 1)
    );
  }, [aOffset]);

  useFrame(({ clock, mouse }) => {
    pointsRef.current.material.uniforms.uTime.value = clock.elapsedTime;

    emissionRef.current.material.uniforms.uTime.value = clock.elapsedTime;

    m.current.lerp(mouse, 0.1);

    camera.rotation.y = -m.current.x * 0.1;
    camera.rotation.x = -0.075 + m.current.y * 0.1;
  });

  const { nodes } = useGLTF(model);

  return (
    <>
      <group ref={group} {...props} dispose={null}>
        <mesh
          geometry={nodes.letters.geometry}
          ref={letters}
          position={[0.05574, 6.93339, -0.00698]}
        >
          <meshBasicMaterial map={bakedTex} />
        </mesh>
        <mesh
          geometry={nodes.air_rock001.geometry}
          ref={airRock1}
          position={[-3.14247, 1.59546, 3.03652]}
        >
          <meshBasicMaterial map={bakedTex} />
        </mesh>
        <mesh
          geometry={nodes.air_rock002.geometry}
          ref={airRock2}
          position={[-2.40939, 11.24023, -2.64953]}
        >
          <meshBasicMaterial map={bakedTex} />
        </mesh>
        <mesh
          geometry={nodes.air_rock003.geometry}
          ref={airRock3}
          position={[4.34263, 7.24577, -2.62799]}
        >
          <meshBasicMaterial map={bakedTex} />
        </mesh>
        <mesh
          geometry={nodes.air_rock.geometry}
          ref={airRock4}
          position={[3.15335, 3.2013, 2.33815]}
        >
          <meshBasicMaterial map={bakedTex} />
        </mesh>
        <Points
          ref={pointsRef}
          position={[-0.20013, -0.70351, 0.21569]}
          scale={[1, 1, 1]}
          range={pointCount}
          positions={points}
        >
          <pointsMaterial />
        </Points>

        <Selection>
          <mesh
            ref={platformRef}
            geometry={nodes.platform.geometry}
            position={[-0.03233, -1.16806, -1.12225]}
          >
            <meshBasicMaterial map={bakedTex} />
          </mesh>
          <Select>
            <mesh
              ref={emissionRef}
              position={[-0.20013, -0.70351, 0.21569]}
              scale={[1.1, 1, 1.1]}
              rotation={[-Math.PI / 2, 0, 0]}
              onPointerMove={(e) =>
                (emissionRef.current.material.uniforms.uMouse.value = e.point)
              }
            >
              <planeGeometry args={[12, 12, 50, 50]} />
              <portalMaterial />
            </mesh>
          </Select>

          <EffectComposer frameBufferType={FloatType} multisampling={8}>
            <SelectiveBloom
              lights={[emissionRef]}
              selection={[platformRef]}
              // width={Resizer.AUTO_SIZE}
              // height={Resizer.AUTO_SIZE}
              // kernelSize={KernelSize.LARGE}
              intensity={1.3}
              luminanceThreshold={0.4}
              luminanceSmoothing={0.8}
            />
          </EffectComposer>
        </Selection>
      </group>
    </>
  );
}

useGLTF.preload(model);
